{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}{\f3\fnil\fcharset0 Calibri;}}
{\colortbl ;\red127\green0\blue85;\red0\green0\blue0;\red106\green62\blue62;\red0\green0\blue192;\red63\green127\blue95;\red127\green159\blue191;\red42\green0\blue255;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\lang9\b\f0\fs22 1.       Find whether 2 strings are anagrams :\par
\par
Fried --- fired\par
Gainly \endash  laying\par
Sadder \endash  dreads\par
\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  AnagramStrings \{\cf0\par
\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b boolean\cf2\b0  findAnagram(String \cf3 s1\cf2 ,String \cf3 s2\cf2 ) \{\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf3 s1\cf2 .length()!=\cf3 s2\cf2 .length()) \cf1\b return\cf2\b0  \cf1\b false\cf2\b0 ;\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 count\cf2 =\cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [256];\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s1\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 count\cf2 [\cf3 s1\cf2 .charAt(\cf3 i\cf2 )]++;\cf0\par
\cf2\tab\tab\tab\cf3 count\cf2 [\cf3 s2\cf2 .charAt(\cf3 i\cf2 )]--;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 count\cf2 .\cf4 length\cf2 -1;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 count\cf2 [\cf3 i\cf2 ]!=0) \cf1\b return\cf2\b0  \cf1\b false\cf2\b0 ;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf1\b true\cf2\b0 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i findAnagram\i0 (\cf7 "surya"\cf2 ,\cf7 "suray"\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
\par
2.       Suppose there are 2 strings source =\rdblquote abcde\rdblquote  target =\rdblquote ab\rdblquote  . Your program should return true if target is there in source. And also if the reverse of target is there in source\par
\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  StringAvailable \{\cf0\par
\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab String \cf3 input\cf2  = \cf7 "abcde"\cf2 ;\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 input\cf2 .contains(\cf7 "ed"\cf2 ));\cf0\par
\cf2\tab\tab\cf1\b boolean\cf2\b0  \cf3 result\cf2  = \cf3 input\cf2 .indexOf(\cf7 "cd"\cf2 )!=-1?\cf1\b true\cf2\b0 :\cf1\b false\cf2\b0 ;\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 result\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\par
\cf0\b\f0\fs22\par
3.       An array has numbers from 1 to 20 . some of the numbers are missing if we sort the numbers in ascending order. Find out the missing numbers.\par
\cf1\f1\fs20\par
public\cf2\b0  \cf1\b class\cf2\b0  ArrayMissingNumber \{\cf0\par
\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  missingNumber(\cf1\b int\cf2\b0  \cf3 a\cf2 []) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 length\cf2  = \cf3 a\cf2 .\cf4 length\cf2 ;\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 sum\cf2 =(\cf3 a\cf2 [\cf3 length\cf2 -1]*(\cf3 a\cf2 [\cf3 length\cf2 -1]+1))/2;\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 sum\cf2  -=\cf3 a\cf2 [\cf3 i\cf2 ];\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf3 sum\cf2 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  = \{1,2,3,5\};\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i missingNumber\i0 (\cf3 arr\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
4.       Find the first non-repeating character in a string  eg: helloworld   h is the answer.\par
\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  NonRepeatCharacter \{\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b char\cf2\b0  firstNonRepeat(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [26];\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 arr\cf2 [\cf3 s\cf2 .charAt(\cf3 i\cf2 )-\cf7 'a'\cf2 ]++;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 arr\cf2 [\cf3 s\cf2 .charAt(\cf3 i\cf2 )-\cf7 'a'\cf2 ]==1) \cf1\b return\cf2\b0  \cf3 s\cf2 .charAt(\cf3 i\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf7 '-'\cf2 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab String \cf3 s\cf2  = \cf7 "suryakumar"\cf2 ;\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i firstNonRepeat\i0 (\cf3 s\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
5.       Find the palindromic permutations for a given string eg: Malayalam\par
\tab{\field{\*\fldinst{HYPERLINK "https://www.geeksforgeeks.org/print-palindromic-permutations-given-string-alphabetic-order/"}}{\fldrslt{\ul\cf8 https://www.geeksforgeeks.org/print-palindromic-permutations-given-string-alphabetic-order/}}}\f0\fs22\par
\par
6.   find out the given string is palindrome.\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  PolyndramTest \{\cf0\par
\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b boolean\cf2\b0  test(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 //Solution 1\cf0\par
\cf2\tab\tab   StringBuffer \cf3 sb\cf2  = \cf1\b new\cf2\b0  StringBuffer(\cf3 s\cf2 );\cf0\par
\cf2\tab\tab   System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 sb\cf2 .reverse());\cf0\par
\cf2\tab\tab   \cf1\b if\cf2\b0 (\cf3 s\cf2 .equals(\cf3 sb\cf2 .toString())) \{ System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "true"\cf2 ); \}\cf0\par
\cf2\tab\tab\cf5 //Solution 2 \cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 i\cf2 =0, \cf3 l\cf2 =\cf3 s\cf2 .length()-1;\tab\tab\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 i\cf2 <\cf3 l\cf2 ) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 s\cf2 .charAt(\cf3 i\cf2 )!=\cf3 s\cf2 .charAt(\cf3 l\cf2 )) \{\cf0\par
\cf2\tab\tab\tab\tab\cf1\b return\cf2\b0  \cf1\b false\cf2\b0 ;\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf3 i\cf2 ++; \cf3 l\cf2 --;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf1\b true\cf2\b0 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Solution 3\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b boolean\cf2\b0  stringReverse(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab String \cf3 s1\cf2 =\cf7 ""\cf2 ;\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2  =\cf3 s\cf2 .length()-1;\cf3 i\cf2 >=0;\cf3 i\cf2 --) \{\cf0\par
\cf2\tab\tab\tab\cf3 s1\cf2 +=\cf3 s\cf2 .charAt(\cf3 i\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf5 //System.out.println(s1);\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf3 s\cf2 .equals(\cf3 s1\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b boolean\cf2\b0  \cf3 b\cf2  = \i test\i0 (\cf7 "surya"\cf2 );\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 b\cf2 );\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b boolean\cf2\b0  \cf3 b1\cf2  = \i stringReverse\i0 (\cf7 "ssssss"\cf2 );\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 b1\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
7.       Find out all palindromic substrings from a give string eg: aabbaacabcadadad\par
\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  PalindromeSubString \{\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  expand(String \cf3 s\cf2 ,\cf1\b int\cf2\b0  \cf3 low\cf2 ,\cf1\b int\cf2\b0  \cf3 high\cf2 ,Set<String> \cf3 set\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 low\cf2 >=0 && \cf3 high\cf2  < \cf3 s\cf2 .length() && \cf3 s\cf2 .charAt(\cf3 low\cf2 )==\cf3 s\cf2 .charAt(\cf3 high\cf2 )) \{\cf0\par
\cf2\tab\tab\tab\cf3 set\cf2 .add(\cf3 s\cf2 .substring(\cf3 low\cf2 , \cf3 high\cf2 +1));\cf0\par
\cf2\tab\tab\tab\cf5 //System.out.println(s.substring(low, high+1));\cf0\par
\cf2\tab\tab\tab\cf3 low\cf2 --;\cf0\par
\cf2\tab\tab\tab\cf3 high\cf2 ++;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  findAllSubstringPalindrom(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 length\cf2  = \cf3 s\cf2 .length();\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf3 s\cf2 ==\cf1\b null\cf2\b0  || \cf3 length\cf2 <1) System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "String is empty"\cf2 );\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf3 length\cf2 <2)System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 s\cf2 );\cf0\par
\cf2\tab\tab Set<String> \cf3 set\cf2  = \cf1\b new\cf2\b0  HashSet<String>();\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf5 //find all odd length \ul palindrome\ulnone  with \ul str\ulnone [i] as mid point\cf0\par
\cf2\tab\tab\tab\i expand\i0 (\cf3 s\cf2 ,\cf3 i\cf2 ,\cf3 i\cf2 ,\cf3 set\cf2 );\cf0\par
\cf2\tab\tab\tab\cf5 //find all  length \ul palindrome\ulnone  with \ul str\ulnone [i] and \ul str\ulnone [i+1]\cf0\par
\cf2\tab\tab\tab\i expand\i0 (\cf3 s\cf2 ,\cf3 i\cf2 ,\cf3 i\cf2 +1,\cf3 set\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 set\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab String \cf3 str\cf2  = \cf7 "google"\cf2 ;\cf0\par
\cf2\tab\tab\i findAllSubstringPalindrom\i0 (\cf3 str\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\b\f0\fs22\par
8.  Find out longest palindromic substrings from a give string eg: google, result : goog\par
\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  PalindromeLongestSubString \{\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  \cf4\i resultstart\cf2\i0 ;\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  \cf4\i resultlength\cf2\i0 ;\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  expand(String \cf3 s\cf2 ,\cf1\b int\cf2\b0  \cf3 low\cf2 ,\cf1\b int\cf2\b0  \cf3 high\cf2 ,Set<String> \cf3 set\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 low\cf2 >=0 && \cf3 high\cf2  < \cf3 s\cf2 .length() && \cf3 s\cf2 .charAt(\cf3 low\cf2 )==\cf3 s\cf2 .charAt(\cf3 high\cf2 )) \{\cf0\par
\cf2\tab\tab\tab\cf3 set\cf2 .add(\cf3 s\cf2 .substring(\cf3 low\cf2 , \cf3 high\cf2 +1));\cf0\par
\cf2\tab\tab\tab\cf5 //System.out.println(s.substring(low, high+1));\cf0\par
\cf2\tab\tab\tab\cf3 low\cf2 --;\cf0\par
\cf2\tab\tab\tab\cf3 high\cf2 ++;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf4\i resultlength\cf2\i0 <\cf3 high\cf2 -\cf3 low\cf2 -1) \{\cf0\par
\cf2\tab\tab\tab\cf4\i resultstart\cf2\i0  = \cf3 low\cf2 +1;\cf0\par
\cf2\tab\tab\tab\cf4\i resultlength\cf2\i0  = \cf3 high\cf2 -\cf3 low\cf2 -1;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  findAllSubstringPalindrom(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 length\cf2  = \cf3 s\cf2 .length();\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf3 s\cf2 ==\cf1\b null\cf2\b0  || \cf3 length\cf2 <1) System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "String is empty"\cf2 );\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (\cf3 length\cf2 <2)System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 s\cf2 );\cf0\par
\cf2\tab\tab Set<String> \cf3 set\cf2  = \cf1\b new\cf2\b0  HashSet<String>();\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf5 //find all odd length \ul palindrome\ulnone  with \ul str\ulnone [i] as mid point\cf0\par
\cf2\tab\tab\tab\i expand\i0 (\cf3 s\cf2 ,\cf3 i\cf2 ,\cf3 i\cf2 ,\cf3 set\cf2 );\cf0\par
\cf2\tab\tab\tab\cf5 //find all  length \ul palindrome\ulnone  with \ul str\ulnone [i] and \ul str\ulnone [i+1]\cf0\par
\cf2\tab\tab\tab\i expand\i0 (\cf3 s\cf2 ,\cf3 i\cf2 ,\cf3 i\cf2 +1,\cf3 set\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 set\cf2 );\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 s\cf2 .substring(\cf4\i resultstart\cf2\i0 ,\cf4\i resultstart\cf2\i0 +\cf4\i resultlength\cf2\i0 ));\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab String \cf3 str\cf2  = \cf7 "google"\cf2 ;\cf0\par
\cf2\tab\tab\i findAllSubstringPalindrom\i0 (\cf3 str\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\par
\lang1033\b\f2 9.Find out the missing number in the array\par
\cf1\f1 public\cf2\b0  \cf1\b class\cf2\b0  ArrayMissingNumber \{\cf0\par
\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  missingNumber(\cf1\b int\cf2\b0  \cf3 a\cf2 []) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 length\cf2  = \cf3 a\cf2 .\cf4 length\cf2 ;\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 sum\cf2 =(\cf3 a\cf2 [\cf3 length\cf2 -1]*(\cf3 a\cf2 [\cf3 length\cf2 -1]+1))/2;\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 sum\cf2  -=\cf3 a\cf2 [\cf3 i\cf2 ];\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf3 sum\cf2 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  = \{1,2,3,5\};\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i missingNumber\i0 (\cf3 arr\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\lang9\b\f0\fs22\par
10.Find out the Nth largest number in array\par
\cf1\f1\fs20 import\cf2\b0  java.util.Arrays;\cf0\par
\cf1\b import\cf2\b0  java.util.List;\cf0\par
\cf1\b import\cf2\b0  java.util.stream.Collectors;\cf0\par
\par
\cf1\b public\cf2\b0  \cf1\b class\cf2\b0  ArrayNthLargest \{\cf0\par
\cf2\tab\cf5 //Solution 1\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b void\cf2\b0  nthLargest(\cf1\b int\cf2\b0 [] \cf3 arr\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 temp\cf2 ;\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 arr\cf2 .\cf4 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 j\cf2 =\cf3 i\cf2 +1;\cf3 j\cf2 <\cf3 arr\cf2 .\cf4 length\cf2 ;\cf3 j\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 arr\cf2 [\cf3 i\cf2 ]>\cf3 arr\cf2 [\cf3 j\cf2 ]) \{\cf0\par
\cf2\tab\tab\tab\tab\tab\cf3 temp\cf2  = \cf3 arr\cf2 [\cf3 i\cf2 ];\cf0\par
\cf2\tab\tab\tab\tab\tab\cf3 arr\cf2 [\cf3 i\cf2 ] = \cf3 arr\cf2 [\cf3 j\cf2 ];\cf0\par
\cf2\tab\tab\tab\tab\tab\cf3 arr\cf2 [\cf3 j\cf2 ] = \cf3 temp\cf2 ;\cf0\par
\cf2\tab\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\tab\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 arr\cf2 [\cf3 arr\cf2 .\cf4 length\cf2 -3]);\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf5 //Solution 2 :By using sorting\cf0\par
\cf2\tab\tab Arrays.\i sort\i0 (\cf3 arr\cf2 );\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 arr\cf2 [\cf3 arr\cf2 .\cf4 length\cf2 -3]);\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf5 //Solution 3 :By using collections\cf0\par
\cf2\tab\tab List<Integer> \cf3 l\cf2  =  Arrays.\i stream\i0 (\cf3 arr\cf2 ).sorted().boxed().collect(Collectors.\i toList\i0 ());\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 l\cf2 .get(\cf3 l\cf2 .size()-3));\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 a\cf2 [] = \{9,2,1,7,8,3\};\cf0\par
\cf2\tab\tab\i nthLargest\i0 (\cf3 a\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
11.Find out the element in array by using binary search\par
\cf1\f1\fs20 import\cf2\b0  java.util.Arrays;\cf0\par
\par
\cf1\b public\cf2\b0  \cf1\b class\cf2\b0  BinarySearch \{\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  binarySearch(\cf1\b int\cf2\b0  \cf3 arr\cf2 [],\cf1\b int\cf2\b0  \cf3 ele\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 left\cf2 =0, \cf3 right\cf2 =\cf3 arr\cf2 .\cf4 length\cf2 -1;\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 left\cf2 <=\cf3 right\cf2 ) \{\cf0\par
\cf2\tab\tab\tab\cf1\b int\cf2\b0  \cf3 mid\cf2  = \cf3 left\cf2 +(\cf3 right\cf2 )/2;\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 arr\cf2 [\cf3 mid\cf2 ]==\cf3 ele\cf2 ) \cf1\b return\cf2\b0  \cf3 mid\cf2 ;\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\tab\cf5 //if \ul ele\ulnone  is greater, ignore left half\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 arr\cf2 [\cf3 mid\cf2 ]<\cf3 ele\cf2 ) \cf3 left\cf2 =\cf3 mid\cf2 +1;\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\tab\cf5 //if \ul ele\ulnone  is smaller, ignoring right half\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 arr\cf2 [\cf3 mid\cf2 ]>\cf3 ele\cf2 ) \cf3 right\cf2 =\cf3 mid\cf2 -1;\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  -1;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  = \{16,8,2,10,11,14\};\cf0\par
\cf2\tab\tab Arrays.\i sort\i0 (\cf3 arr\cf2 );\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 index\cf2  = \i binarySearch\i0 (\cf3 arr\cf2 ,16);\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "element index : "\cf2 +\cf3 index\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22 12. Find out the charecter count of given string \par
\cf1\f1\fs20 import\cf2\b0  java.util.LinkedHashMap;\cf0\par
\par
\cf1\b public\cf2\b0  \cf1\b class\cf2\b0  CharactersCount \{\cf0\par
\cf2\tab\cf5 //Solution 1\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b void\cf2\b0  getOccuringChar(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 count\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [256];\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 count\cf2 [\cf3 s\cf2 .charAt(\cf3 i\cf2 )]++;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b char\cf2\b0 [] \cf3 ca\cf2  = \cf1\b new\cf2\b0  \cf1\b char\cf2\b0 [\cf3 s\cf2 .length()];\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf3 ca\cf2 [\cf3 i\cf2 ] = \cf3 s\cf2 .charAt(\cf3 i\cf2 );\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\tab\cf1\b int\cf2\b0  \cf3 find\cf2  = 0;\cf0\par
\cf2\tab\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 j\cf2 =0;\cf3 j\cf2 <=\cf3 i\cf2 ;\cf3 j\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 s\cf2 .charAt(\cf3 i\cf2 )==\cf3 ca\cf2 [\cf3 j\cf2 ]) \{\cf0\par
\cf2\tab\tab\tab\tab\tab\cf3 find\cf2 ++;\cf0\par
\cf2\tab\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 find\cf2  == 1)\cf0\par
\cf2\tab\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Occurence of char : "\cf2 +\cf3 s\cf2 .charAt(\cf3 i\cf2 )+\cf7 " in the string is : "\cf2 +\cf3 count\cf2 [\cf3 s\cf2 .charAt(\cf3 i\cf2 )]);\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf0\par
\cf2\tab  \cf0\par
\cf2\tab  \cf1\b static\cf2\b0  \cf1\b int\cf2\b0  hashFunc(\cf1\b char\cf2\b0  \cf3 c\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  (\cf3 c\cf2 -\cf7 'a'\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Solution 2: by using hashing technique\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b void\cf2\b0  countCharByUsingHash(String \cf3 s\cf2 ) \{\cf0\par
\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 freq\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [26];\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf5 //\ul int\ulnone  index = hashFunc(s.charAt(i));\cf0\par
\cf2\tab\tab\tab\cf1\b int\cf2\b0  \cf3 index\cf2  = \cf3 s\cf2 .charAt(\cf3 i\cf2 )-\cf7 'a'\cf2 ;\cf0\par
\cf2\tab\tab\tab\cf3 freq\cf2 [\cf3 index\cf2 ]++;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <26;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 freq\cf2 [\cf3 i\cf2 ]>0)\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "String character : "\cf2 +(\cf1\b char\cf2\b0 )(\cf3 i\cf2 +\cf7 'a'\cf2 )+\cf7 " : count is :"\cf2 +\cf3 freq\cf2 [\cf3 i\cf2 ]);\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf5 //Solution 3 :by using collections\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b void\cf2\b0  getOccuringChar1(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab LinkedHashMap<Character,Integer> \cf3 charMap\cf2  = \cf1\b new\cf2\b0  LinkedHashMap<Character, Integer>();\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b char\cf2\b0  \cf3 c\cf2 :\cf3 s\cf2 .toCharArray()) \{\cf0\par
\cf2\tab\tab\tab  \cf1\b if\cf2\b0 (\cf3 charMap\cf2 .containsKey(\cf3 c\cf2 )) \{\cf0\par
\cf2\tab\tab\tab\tab  \cf3 charMap\cf2 .put(\cf3 c\cf2 , \cf3 charMap\cf2 .get(\cf3 c\cf2 )+1);\cf0\par
\cf2\tab\tab\tab  \}\cf1\b else\cf2\b0  \{\cf0\par
\cf2\tab\tab\tab\tab  \cf3 charMap\cf2 .put(\cf3 c\cf2 , 1);\cf0\par
\cf2\tab\tab\tab  \}\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf3 charMap\cf2 .forEach((\cf3 k\cf2 ,\cf3 v\cf2 )->System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 k\cf2 +\cf7 ":"\cf2 +\cf3 v\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf5 //getOccuringChar("\ul suryakumar\ulnone ");\cf0\par
\cf2\tab\tab\cf5 //getOccuringChar1("\ul suryakumar\ulnone ");\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\i countCharByUsingHash\i0 (\cf7 "suryakumar"\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22 13. Find out the first duplicate element in the array/ given string.\par
\cf1\f1\fs20 import\cf2\b0  java.util.HashSet;\cf0\par
\cf1\b import\cf2\b0  java.util.Set;\cf0\par
\par
\cf1\b public\cf2\b0  \cf1\b class\cf2\b0  FirstDuplicate \{\cf0\par
\par
\cf2\tab\cf5 //Solution for integer array\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b int\cf2\b0  firstDuplicateInt(\cf1\b int\cf2\b0 [] \cf3 a\cf2 ) \{\cf0\par
\cf2\tab\tab Set<Integer> \cf3 set\cf2  = \cf1\b new\cf2\b0  HashSet<Integer>();\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 :\cf3 a\cf2 ) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 set\cf2 .contains(\cf3 i\cf2 ))\{\cf0\par
\cf2\tab\tab\tab\tab\cf1\b return\cf2\b0  \cf3 i\cf2 ;\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf3 set\cf2 .add(\cf3 i\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  -1;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Solution for the first duplicate character in the given string\cf0\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b char\cf2\b0  firstDuplicateChar(String \cf3 s\cf2 ) \{\cf0\par
\cf2\tab\tab Set<Character> \cf3 set\cf2  = \cf1\b new\cf2\b0  HashSet<Character>();\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 s\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b if\cf2\b0 (\cf3 set\cf2 .contains(\cf3 s\cf2 .charAt(\cf3 i\cf2 )))\{\cf0\par
\cf2\tab\tab\tab\tab\cf1\b return\cf2\b0  \cf3 s\cf2 .charAt(\cf3 i\cf2 );\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf3 set\cf2 .add(\cf3 s\cf2 .charAt(\cf3 i\cf2 ));\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf7 '-'\cf2 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  =\{1,2,3,4,1\};\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i firstDuplicateInt\i0 (\cf3 arr\cf2 ));\cf0\par
\cf2\tab\tab String \cf3 s\cf2  = \cf7 "suryakumar"\cf2 ;\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\i firstDuplicateChar\i0 (\cf3 s\cf2 ));\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
14. Sorting the array incresing order eg: 0,2,0,1,2,0,1,1,0,0 Result : 0,0,0,0,1,1,1,2,2\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  SortedIncreasingOrder \{\cf0\par
\par
\cf2\tab\cf1\b static\cf2\b0  \cf1\b void\cf2\b0  sort012IncreaseOrder(\cf1\b int\cf2\b0 [] \cf3 arr\cf2 ) \{\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 cnt0\cf2 =0,\cf3 cnt1\cf2 =0,\cf3 cnt2\cf2 =0;\cf0\par
\cf2\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf3 arr\cf2 .\cf4 length\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\cf1\b switch\cf2\b0 (\cf3 arr\cf2 [\cf3 i\cf2 ]) \{\cf0\par
\cf2\tab\tab\tab\cf1\b case\cf2\b0  0:\cf0\par
\cf2\tab\tab\tab\tab\cf3 cnt0\cf2 ++;\cf0\par
\cf2\tab\tab\tab\tab\cf1\b break\cf2\b0 ;\cf0\par
\cf2\tab\tab\tab\cf1\b case\cf2\b0  1:\cf0\par
\cf2\tab\tab\tab\tab\cf3 cnt1\cf2 ++;\cf0\par
\cf2\tab\tab\tab\tab\cf1\b break\cf2\b0 ;\cf0\par
\cf2\tab\tab\tab\cf1\b case\cf2\b0  2:\cf0\par
\cf2\tab\tab\tab\tab\cf3 cnt2\cf2 ++;\cf0\par
\cf2\tab\tab\tab\tab\cf1\b break\cf2\b0 ;\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 cnt0\cf2 >0) \{\cf0\par
\cf2\tab\tab\tab\cf3 arr\cf2 [\cf3 i\cf2 ++] =0;\cf0\par
\cf2\tab\tab\tab\cf3 cnt0\cf2 --;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 cnt1\cf2 >0) \{\cf0\par
\cf2\tab\tab\tab\cf3 arr\cf2 [\cf3 i\cf2 ++] =1;\cf0\par
\cf2\tab\tab\tab\cf3 cnt1\cf2 --;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf1\b while\cf2\b0 (\cf3 cnt2\cf2 >0) \{\cf0\par
\cf2\tab\tab\tab\cf3 arr\cf2 [\cf3 i\cf2 ++] =2;\cf0\par
\cf2\tab\tab\tab\cf3 cnt2\cf2 --;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 arr\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab\cf1\b int\cf2\b0 [] \cf3 arr\cf2  = \{1,0,2,1,1,0,2,0,2,0\};\cf0\par
\cf2\tab\tab\i sort012IncreaseOrder\i0 (\cf3 arr\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22 15. Implement Stack class\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  Stack \{\cf0\par
\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 arr\cf2 [];\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 capacity\cf2 ;\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 top\cf2 ;\cf0\par
\cf2\tab Stack(\cf1\b int\cf2\b0  \cf3 size\cf2 )\{\cf0\par
\cf2\tab\tab\cf4 arr\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [\cf3 size\cf2 ];\cf0\par
\cf2\tab\tab\cf4 capacity\cf2  = \cf3 size\cf2 ;\cf0\par
\cf2\tab\tab\cf4 top\cf2 =-1;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //inserting the elements into stack\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b void\cf2\b0  push(\cf1\b int\cf2\b0  \cf3 ele\cf2 ) \{\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (isFull()) \{\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "--stack is full so increasing capacity--"\cf2 );\cf0\par
\cf2\tab\tab\tab\cf1\b int\cf2\b0 [] \cf3 new_arr\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [\cf4 capacity\cf2 *2];\cf0\par
\cf2\tab\tab\tab\cf0\par
\cf2\tab\tab\tab\cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =0;\cf3 i\cf2 <\cf4 capacity\cf2 ;\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab\tab\tab\cf3 new_arr\cf2 [\cf3 i\cf2 ] = \cf4 arr\cf2 [\cf3 i\cf2 ];\cf0\par
\cf2\tab\tab\tab\}\cf0\par
\cf2\tab\tab\tab\cf4 capacity\cf2 =\cf4 capacity\cf2 *2;\cf0\par
\cf2\tab\tab\tab  \cf4 arr\cf2  = \cf3 new_arr\cf2 ;\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf4 arr\cf2 [++\cf4 top\cf2 ] = \cf3 ele\cf2 ;\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "element added: "\cf2 +\cf3 ele\cf2 );\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf5 //retrieve and remove the elements\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b int\cf2\b0  pop() \{\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (isEmpty()) \{\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "--stack is empty--"\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "remove element : "\cf2 +\cf4 arr\cf2 [\cf4 top\cf2 ]);\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf4 arr\cf2 [\cf4 top\cf2 --];\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf5 //retrieve element without remove\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b int\cf2\b0  peak() \{\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Just peak the element : "\cf2 +\cf4 arr\cf2 [\cf4 top\cf2 ]);\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf4 arr\cf2 [\cf4 top\cf2 ];\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //check the stack is empty\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b boolean\cf2\b0  isEmpty() \{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  (\cf4 top\cf2 ==-1);\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //check the stack is full\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b boolean\cf2\b0  isFull() \{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  (\cf4 top\cf2  == \cf4 capacity\cf2 -1);\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab Stack \cf3 stack\cf2  = \cf1\b new\cf2\b0  Stack(3);\cf0\par
\cf2\tab\tab\cf3 stack\cf2 .push(1);\cf3 stack\cf2 .push(2);\cf3 stack\cf2 .push(3);\cf3 stack\cf2 .push(4);\cf3 stack\cf2 .push(5);\cf3 stack\cf2 .push(6);\cf0\par
\cf2\tab\tab\cf3 stack\cf2 .pop();\cf3 stack\cf2 .peak();\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
16. Implement the Queue class\par
\cf1\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  Queue \{\cf0\par
\cf2\tab\cf1\b int\cf2\b0 [] \cf4 arr\cf2 ;\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 capacity\cf2 ;\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 front\cf2 ;\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 last\cf2 ;\cf0\par
\cf2\tab\cf1\b int\cf2\b0  \cf4 count\cf2 ;\cf0\par
\cf2\tab Queue(\cf1\b int\cf2\b0  \cf3 size\cf2 )\{\cf0\par
\cf2\tab\tab\cf4 arr\cf2  = \cf1\b new\cf2\b0  \cf1\b int\cf2\b0 [\cf3 size\cf2 ];\cf0\par
\cf2\tab\tab\cf4 capacity\cf2  = \cf3 size\cf2 ;\cf0\par
\cf2\tab\tab\cf4 front\cf2  =0;\cf0\par
\cf2\tab\tab\cf4 last\cf2 =-1;\cf0\par
\cf2\tab\tab\cf4 count\cf2  = 0;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf0\par
\cf2\tab\cf5 //inserting an elements into Queue\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b void\cf2\b0  enqueue(\cf1\b int\cf2\b0  \cf3 ele\cf2 )\{\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (isFull()) \{\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Queue is full"\cf2 );\cf0\par
\cf2\tab\tab\tab System.\i exit\i0 (0);\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab\cf4 last\cf2 =(\cf4 last\cf2 +1)%\cf4 capacity\cf2 ;\tab\tab\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Inserting an element : "\cf2 +\cf3 ele\cf2 +\cf7 " at index : "\cf2 +\cf4 last\cf2 );\cf0\par
\cf2\tab\tab\cf4 arr\cf2 [\cf4 last\cf2 ] = \cf3 ele\cf2 ;\cf0\par
\cf2\tab\tab\cf4 count\cf2 ++;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Removing an element from Queue\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b void\cf2\b0  dequeue() \{\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (isEmpty()) \{\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Queue is empty"\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Removing an element : "\cf2 +\cf4 arr\cf2 [\cf4 front\cf2 ]+\cf7 " at index : "\cf2 +\cf4 front\cf2 );\cf0\par
\cf2\tab\tab\cf4 front\cf2  = (\cf4 front\cf2 +1)%\cf4 capacity\cf2 ;\cf0\par
\cf2\tab\tab\cf4 count\cf2 --;\cf0\par
\cf2\tab\tab\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Returning the element without remove\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b int\cf2\b0  peak() \{\cf0\par
\cf2\tab\tab\cf1\b if\cf2\b0 (isEmpty()) \{\cf0\par
\cf2\tab\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Queue is empty"\cf2 );\cf0\par
\cf2\tab\tab\}\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Peak the element : "\cf2 +\cf4 arr\cf2 [\cf4 front\cf2 ]);\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf4 arr\cf2 [\cf4 front\cf2 ];\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf5 //Size of the Queue\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b int\cf2\b0  size() \{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  \cf4 count\cf2 ;\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b boolean\cf2\b0  isFull() \{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0   (\cf4 capacity\cf2  == size());\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b boolean\cf2\b0  isEmpty()\{\cf0\par
\cf2\tab\tab\cf1\b return\cf2\b0  (size()==0);\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab Queue \cf3 qu\cf2  = \cf1\b new\cf2\b0  Queue(2);\cf0\par
\cf2\tab\tab\cf3 qu\cf2 .enqueue(1);\cf0\par
\cf2\tab\tab\cf3 qu\cf2 .enqueue(2);\tab\tab\cf0\par
\cf2  \tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Size : "\cf2 +\cf3 qu\cf2 .size());\cf0\par
\cf2\tab\tab\cf3 qu\cf2 .peak();\cf3 qu\cf2 .peak();\cf0\par
\cf2\tab\tab\cf3 qu\cf2 .dequeue();\cf3 qu\cf2 .dequeue();\cf0\par
\cf2\tab\tab System.\cf4\b\i out\cf2\b0\i0 .println(\cf7 "Size : "\cf2 +\cf3 qu\cf2 .size());\cf0\par
\cf2\tab\}\cf0\par
\par
\cf2\}\cf0\par
\b\f0\fs22\par
17.       Problem Statement:\par
Line1 is a dictionary of words. Convert Line 2 to a meaningful sentence by referring to the words in Line1.\par
\par
Example1:\par
// String line1 = "I,A,AM,HE,HERE";\par
// String line2 = "IAMHERE";\par
Solution :I AM HERE\par
\par
Example2: \par
//String line1 = "he,hello,the,there";\par
//String line2 = "hellothere";\par
Solution: hello there\par
\pard\sa200\sl276\slmult1\b0\f3\par
\pard\sa200\sl240\slmult1\cf1\b\f1\fs20 public\cf2\b0  \cf1\b class\cf2\b0  WordBreak \{\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  wordBreak(String \cf3 dict\cf2 , String \cf3 str\cf2 ,String \cf3 out\cf2 )\cf0\par
\cf2\tab\{\cf0\par
\cf2\tab  \cf1\b if\cf2\b0  (\cf3 str\cf2 .length() == 0) \{  System.\cf4\b\i out\cf2\b0\i0 .println(\cf3 out\cf2 ); \}\cf0\par
\cf2\tab   \cf1\b for\cf2\b0 (\cf1\b int\cf2\b0  \cf3 i\cf2 =1;\cf3 i\cf2 <=\cf3 str\cf2 .length();\cf3 i\cf2 ++) \{\cf0\par
\cf2\tab\tab   String \cf3 prefix\cf2  = \cf3 str\cf2 .substring(0, \cf3 i\cf2 );\cf0\par
\cf2\tab\tab   \cf1\b if\cf2\b0 (\cf3 dict\cf2 .contains(\cf3 prefix\cf2 )) \{\cf0\par
\cf2\tab\tab\tab   \i wordBreak\i0 (\cf3 dict\cf2 , \cf3 str\cf2 .substring(\cf3 i\cf2 ),\cf3 out\cf2 +\cf7 " "\cf2 +\cf3 prefix\cf2 );\cf0\par
\cf2\tab\tab   \}\cf0\par
\cf2\tab   \}\cf0\par
\cf2\tab\}\cf0\par
\cf2\tab\cf1\b public\cf2\b0  \cf1\b static\cf2\b0  \cf1\b void\cf2\b0  main(String[] \cf3 args\cf2 ) \{\cf0\par
\cf2\tab\tab\cf5 // \cf6\b TODO\cf5\b0  Auto-generated method stub\cf0\par
\cf2\tab\tab String \cf3 s1\cf2  = \cf7 "I,A,AM,HE,HERE"\cf2 ;\cf0\par
\cf2\tab\tab String \cf3 s2\cf2  = \cf7 "IAM\lang1033\f2 HERE\lang9\f1 "\cf2 ;\cf0\par
\cf2\tab\tab\i wordBreak\i0 (\cf3 s1\cf2 , \cf3 s2\cf2 ,\cf7 ""\cf2 );\cf0\par
\cf2\tab\}\cf0\par
\cf2\}\cf0\f3\fs22\par
\pard\sa200\sl276\slmult1\par
}
 